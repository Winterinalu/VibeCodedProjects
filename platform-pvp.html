<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON CIRCUIT: ARENA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Typography: Orbitron for UI, Roboto Mono for body */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');
        
        :root {
            --bg-color: #0B0F1A;
            --panel-color: #11162A;
            --border-color: #1B2140;
            --neon-cyan: #00F5FF;
            --neon-magenta: #FF2ED1;
            --neon-purple: #7C3AED;
            --text-primary: #E5E7EB;
            --text-muted: #9CA3AF;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            touch-action: none;
            margin: 0;
        }

        /* Scanline Overlay */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
        }

        /* CRT Flicker Animation */
        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.9; }
            15% { opacity: 0.95; }
            20% { opacity: 0.98; }
            50% { opacity: 0.95; }
            100% { opacity: 0.98; }
        }

        #game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            animation: flicker 4s infinite;
        }

        canvas {
            background: radial-gradient(circle at center, #16213e 0%, #0B0F1A 100%);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.1), 0 0 40px rgba(255, 46, 209, 0.1);
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--neon-cyan);
            border-bottom: 2px solid var(--neon-magenta);
        }

        .ui-layer {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            padding: 0 50px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }

        .player-label {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1.2rem;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
            text-shadow: 0 0 10px currentColor;
        }

        .health-bar-container {
            width: 100%;
            height: 24px;
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            position: relative;
            transform: skewX(-20deg);
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .health-bar {
            height: 100%;
            transition: width 0.1s linear;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }

        .p1-health { 
            background: linear-gradient(90deg, var(--neon-cyan), #0099ff); 
            box-shadow: 0 0 15px var(--neon-cyan);
        }
        .p2-health { 
            background: linear-gradient(90deg, #ff0055, var(--neon-magenta)); 
            box-shadow: 0 0 15px var(--neon-magenta);
            float: right; 
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 12px;
            color: var(--text-muted);
            text-align: center;
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
            width: 100%;
            max-width: 1024px;
        }

        /* Screens: Start, Result */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(11, 15, 26, 0.92);
            z-index: 10;
            backdrop-filter: blur(8px);
        }

        #result-screen { display: none; }
        #start-screen { display: flex; }

        h1.title-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 48px;
            margin-bottom: 40px;
            color: white;
            text-shadow: 
                2px 2px 0px var(--neon-cyan),
                -2px -2px 0px var(--neon-magenta);
            letter-spacing: 0.15em;
        }

        .btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 15px 40px;
            margin: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-out;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            position: relative;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
        }

        .btn:hover {
            background: rgba(0, 245, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.4);
            transform: translateY(-2px);
            text-shadow: 0 0 8px var(--neon-cyan);
        }

        .btn.secondary {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }
        
        .btn.secondary:hover {
            background: rgba(255, 46, 209, 0.1);
            box-shadow: 0 0 20px rgba(255, 46, 209, 0.4);
            text-shadow: 0 0 8px var(--neon-magenta);
        }

        .key-badge {
            background: var(--panel-color);
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        
        .timer-box {
            background: var(--panel-color);
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--neon-cyan);
            border-right: 4px solid var(--neon-magenta);
            transform: skewX(-20deg);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        
        .timer-text {
            transform: skewX(20deg);
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            text-shadow: 0 0 5px white;
        }

        .unit-container {
            width: 45%;
        }
        
        .hud-text {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 4px;
        }
    </style>
</head>
<body>

<div class="scanlines"></div>

<div id="game-container">
    <div class="ui-layer">
        <!-- Player 1 UI -->
        <div class="unit-container">
            <div class="player-label" style="color: var(--neon-cyan);">UNIT ALPHA</div>
            <div class="health-bar-container">
                <div id="p1-health" class="health-bar p1-health"></div>
            </div>
            <div class="hud-text">CORE INTEGRITY</div>
        </div>

        <!-- Timer / VS -->
        <div class="timer-box">
            <span id="timer" class="timer-text">60</span>
        </div>

        <!-- Player 2 UI -->
        <div class="unit-container" style="text-align: right;">
            <div class="player-label" style="color: var(--neon-magenta);">UNIT OMEGA</div>
            <div class="health-bar-container">
                <div id="p2-health" class="health-bar p2-health"></div>
            </div>
            <div class="hud-text" style="text-align: right;">CORE INTEGRITY</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div class="controls-hint">
        <div class="flex gap-16 justify-center mt-2">
            <div style="color: var(--neon-cyan);">
                <span style="font-family: 'Orbitron'; font-weight: bold; margin-bottom: 5px; display: block; text-shadow: 0 0 5px var(--neon-cyan);">UNIT ALPHA</span> 
                <span class="key-badge">WASD</span> NAVIGATE <br><br>
                <span class="key-badge">F</span> OFFENSE &nbsp;
                <span class="key-badge">G</span> DEFENSE
            </div>
            <div style="color: var(--neon-magenta);">
                <span style="font-family: 'Orbitron'; font-weight: bold; margin-bottom: 5px; display: block; text-shadow: 0 0 5px var(--neon-magenta);">UNIT OMEGA</span> 
                <span class="key-badge">ARROWS</span> NAVIGATE <br><br>
                <span class="key-badge">NUM 0</span> OFFENSE &nbsp;
                <span class="key-badge">NUM .</span> DEFENSE
            </div>
        </div>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay-screen">
        <h1 class="title-text">NEON CIRCUIT</h1>
        <button class="btn" onclick="startGame('pvp')">JACK IN: PVP</button>
        <button class="btn secondary" onclick="startGame('ai')">SIMULATION (AI)</button>
    </div>

    <!-- RESULT SCREEN -->
    <div id="result-screen" class="overlay-screen">
        <h1 id="result-text" class="title-text">SEQUENCE COMPLETE</h1>
        <div style="display: flex; gap: 20px;">
            <button class="btn" onclick="resetMatch()">REBOOT</button>
            <button class="btn secondary" onclick="showMainMenu()">SYSTEM MENU</button>
            <button class="btn secondary" onclick="window.location.href='index.html'">RETURN TO MAINFRAME</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const c = canvas.getContext('2d');
    
    // Game constants
    canvas.width = 1024;
    canvas.height = 576;
    const GRAVITY = 0.7;
    const JUMP_FORCE = -16;
    const MOVE_SPEED = 6;
    const GROUND_HEIGHT = 96;

    // UI Elements
    const p1HealthBar = document.getElementById('p1-health');
    const p2HealthBar = document.getElementById('p2-health');
    const resultScreen = document.getElementById('result-screen');
    const startScreen = document.getElementById('start-screen');
    const resultText = document.getElementById('result-text');
    const timerElement = document.getElementById('timer');

    // Game State
    let gameRunning = false;
    let gameMode = 'pvp'; // 'pvp' or 'ai'
    let timer = 60;
    let timerId;
    let particles = []; 

    // AI Variables
    let aiLastKey = '';
    const aiKeys = {
        ArrowLeft: { pressed: false },
        ArrowRight: { pressed: false },
        ArrowUp: { pressed: false }
    };
    let aiDecisionTimer = 0;

    // Input handling
    const keys = {
        // P1
        a: { pressed: false },
        d: { pressed: false },
        w: { pressed: false },
        // P2 (Human)
        ArrowLeft: { pressed: false },
        ArrowRight: { pressed: false },
        ArrowUp: { pressed: false }
    };

    class Particle {
        constructor({ position, velocity, color }) {
            this.position = position;
            this.velocity = velocity;
            this.color = color;
            this.radius = Math.random() * 3 + 1;
            this.life = 1.0;
        }
        draw() {
            c.save();
            c.globalAlpha = this.life;
            c.shadowBlur = 10;
            c.shadowColor = this.color;
            c.fillStyle = this.color;
            c.beginPath();
            c.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        }
        update() {
            this.draw();
            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;
            this.velocity.y += 0.2; // gravity
            this.life -= 0.05;
        }
    }

    class Player {
        constructor({ position, velocity, color, glowColor, offset = {x: 0, y: 0}, facingRight = true, weaponColor = '#E5E7EB' }) {
            this.position = position;
            this.velocity = velocity;
            this.color = color;
            this.glowColor = glowColor;
            this.weaponColor = weaponColor;
            
            // Hitbox dimensions
            this.width = 50;
            this.height = 120;
            
            // State
            this.isAttacking = false;
            this.isBlocking = false;
            this.attackBox = {
                position: { x: this.position.x, y: this.position.y },
                offset: offset,
                width: 140, 
                height: 100
            };
            this.health = 100;
            this.dead = false;
            
            // Animation State
            this.facingRight = facingRight;
            this.isJumping = false;
            this.lastKey = '';
            this.attackCooldown = false;
            this.animationFrame = 0;
        }

        draw() {
            this.animationFrame++;
            const time = Date.now() * 0.01;

            c.save();
            const centerX = this.position.x + this.width / 2;
            const bottomY = this.position.y + this.height;
            c.translate(centerX, bottomY);
            if (!this.facingRight) c.scale(-1, 1);

            let bodyY = -60; 
            let legAngleL = 0;
            let legAngleR = 0;
            let armAngle = 0;
            let weaponAngle = -Math.PI / 4; 
            
            if (Math.abs(this.velocity.x) > 0 && !this.isJumping) {
                legAngleL = Math.sin(time) * 0.5;
                legAngleR = Math.sin(time + Math.PI) * 0.5;
                armAngle = Math.sin(time) * 0.5;
                bodyY += Math.sin(time * 2) * 2;
            } else if (this.isJumping) {
                legAngleL = -0.5; legAngleR = 0.2; armAngle = -0.5; weaponAngle = -Math.PI / 2;
            } else {
                bodyY += Math.sin(time * 0.5) * 1; 
                armAngle = Math.sin(time * 0.5) * 0.1;
            }

            if (this.isAttacking) {
                armAngle = Math.PI / 3; weaponAngle = Math.PI / 3;
            }
            if (this.isBlocking) {
                armAngle = -Math.PI / 3; weaponAngle = -Math.PI / 4;
            }
            if (this.dead) {
                c.rotate(Math.PI / 2); c.translate(0, -50);
                bodyY = 0; legAngleL = 0; legAngleR = 0;
            }

            // Neon Glow Effect for Player
            c.shadowBlur = 20;
            c.shadowColor = this.glowColor;

            const skinColor = '#1F2937'; // Dark skin for robot look
            const clothColor = this.color;

            // Back Leg
            c.save(); c.translate(0, bodyY); c.rotate(legAngleR);
            c.fillStyle = '#111827'; c.fillRect(-8, 0, 16, 60); c.restore();

            // Body
            c.fillStyle = clothColor; c.fillRect(-15, bodyY - 50, 30, 50);
            // Core Light
            c.fillStyle = 'white'; c.fillRect(-5, bodyY - 35, 10, 10);

            // Head
            c.fillStyle = skinColor; c.fillRect(-12, bodyY - 74, 24, 24); 
            c.fillStyle = clothColor; c.fillRect(-12, bodyY - 74, 24, 8); // Visor top
            // Digital Eye
            c.fillStyle = this.glowColor; 
            c.fillRect(4, bodyY - 66, 10, 4); // Visor eye
            c.shadowBlur = 10; c.shadowColor = this.glowColor; // Eye Glow

            // Front Leg
            c.save(); c.translate(0, bodyY); c.rotate(legAngleL);
            c.fillStyle = '#1F2937'; c.fillRect(-8, 0, 16, 60); c.restore();

            // Arm & Weapon
            c.save(); c.translate(0, bodyY - 40); c.rotate(armAngle);
            c.shadowBlur = 0; // Reset shadow for arm details
            c.fillStyle = skinColor; c.fillRect(-6, 0, 12, 35);
            c.translate(0, 30); c.rotate(weaponAngle);
            
            // Handle
            c.fillStyle = '#374151'; c.fillRect(-3, -5, 6, 15);
            c.fillStyle = this.glowColor; c.beginPath(); c.arc(0, 10, 4, 0, Math.PI*2); c.fill();

            // Blade (Laser)
            c.fillStyle = 'white'; // Inner white
            c.shadowBlur = 15; c.shadowColor = this.glowColor; // Colored Glow
            
            if (this.isBlocking) { 
                c.shadowBlur = 25; 
                c.fillStyle = this.glowColor;
            }
            c.fillRect(-4, -60, 8, 60); 
            c.shadowBlur = 0;
            
            // Attack trail
            if (this.isAttacking) {
                c.globalAlpha = 0.5; 
                c.fillStyle = this.glowColor;
                c.beginPath(); c.arc(0, -30, 70, Math.PI, 1.5 * Math.PI); c.fill();
                c.globalAlpha = 1.0;
            }
            c.restore(); 

            // Shield Effect
            if (this.isBlocking) {
                c.strokeStyle = this.glowColor; c.lineWidth = 3;
                c.shadowBlur = 20; c.shadowColor = this.glowColor;
                c.beginPath(); c.arc(0, bodyY - 25, 50, -Math.PI/3, Math.PI/3); c.stroke();
                c.shadowBlur = 0;
            }
            c.restore(); 
        }

        update() {
            this.draw();
            if (this.facingRight) {
                this.attackBox.position.x = this.position.x + this.width - 40; 
            } else {
                this.attackBox.position.x = this.position.x - this.attackBox.width + 40;
            }
            this.attackBox.position.y = this.position.y + 20;

            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            if (this.position.y + this.height + this.velocity.y >= canvas.height - GROUND_HEIGHT) {
                this.velocity.y = 0;
                this.position.y = canvas.height - GROUND_HEIGHT - this.height;
                this.isJumping = false;
            } else {
                this.velocity.y += GRAVITY;
            }

            if (this.position.x < 0) { this.position.x = 0; this.velocity.x = 0; }
            if (this.position.x + this.width > canvas.width) { this.position.x = canvas.width - this.width; this.velocity.x = 0; }
        }

        attack() {
            if (this.attackCooldown || this.dead || this.isBlocking) return;
            this.isAttacking = true;
            this.attackCooldown = true;
            setTimeout(() => { this.isAttacking = false; }, 150);
            setTimeout(() => { this.attackCooldown = false; }, 500);
        }

        block(active) {
            if (this.dead) return;
            this.isBlocking = active;
        }

        takeHit(damage) {
            // Sparks
            for(let i=0; i<8; i++) {
                particles.push(new Particle({
                    position: { x: this.position.x + this.width/2, y: this.position.y + this.height/2 },
                    velocity: { x: (Math.random() - 0.5) * 10, y: (Math.random() - 0.5) * 10 },
                    color: this.isBlocking ? '#FFFFFF' : this.glowColor
                }));
            }
            if (this.isBlocking) { this.health -= damage * 0.1; } 
            else { this.health -= damage; }
            if (this.health <= 0) { this.health = 0; this.dead = true; }
        }
    }

    // Initialization with NEON Colors
    const COLOR_P1 = '#00F5FF'; // Neon Cyan
    const COLOR_P2 = '#FF2ED1'; // Neon Magenta

    let player1 = new Player({
        position: { x: 100, y: 0 }, velocity: { x: 0, y: 0 }, color: '#164E63', glowColor: COLOR_P1, facingRight: true
    });
    let player2 = new Player({
        position: { x: 800, y: 0 }, velocity: { x: 0, y: 0 }, color: '#701A75', glowColor: COLOR_P2, facingRight: false
    });

    // --- AI LOGIC ---
    function updateAI() {
        if (player2.dead || !gameRunning) return;

        const dx = player1.position.x - player2.position.x;
        const distance = Math.abs(dx);
        const attackRange = 100;
        
        aiKeys.ArrowLeft.pressed = false;
        aiKeys.ArrowRight.pressed = false;
        aiKeys.ArrowUp.pressed = false;

        if (player1.isAttacking && distance < 150 && Math.random() > 0.1) {
             player2.block(true);
             return;
        } else {
             player2.block(false);
        }

        if (distance < attackRange && !player2.attackCooldown) {
            if (Math.random() > 0.05) player2.attack();
        }

        if (distance > 80) {
            if (dx > 0) { aiKeys.ArrowRight.pressed = true; aiLastKey = 'ArrowRight'; } 
            else { aiKeys.ArrowLeft.pressed = true; aiLastKey = 'ArrowLeft'; }
        } else if (distance < 40) {
             if (dx > 0) { aiKeys.ArrowLeft.pressed = true; aiLastKey = 'ArrowLeft'; } 
             else { aiKeys.ArrowRight.pressed = true; aiLastKey = 'ArrowRight'; }
        }

        if ((player1.position.y < player2.position.y - 50 || Math.random() < 0.01) && !player2.isJumping) {
            player2.velocity.y = JUMP_FORCE;
            player2.isJumping = true;
        }
    }

    function rectangularCollision({ rectangle1, rectangle2 }) {
        return (
            rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x &&
            rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width &&
            rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
            rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
        );
    }

    function determineWinner({ player1, player2, timerId }) {
        clearTimeout(timerId);
        gameRunning = false;
        resultScreen.style.display = 'flex';
        
        if (player1.health === player2.health) {
            resultText.innerText = 'DRAW';
            resultText.style.color = 'white';
            resultText.style.textShadow = '0 0 10px white';
        } else if (player1.health > player2.health) {
            resultText.innerText = 'UNIT ALPHA VICTORIOUS';
            resultText.style.color = COLOR_P1;
            resultText.style.textShadow = `0 0 20px ${COLOR_P1}`;
        } else {
            resultText.innerText = 'UNIT OMEGA VICTORIOUS';
            resultText.style.color = COLOR_P2;
            resultText.style.textShadow = `0 0 20px ${COLOR_P2}`;
        }
    }

    function decreaseTimer() {
        if (timer > 0 && gameRunning) {
            timerId = setTimeout(decreaseTimer, 1000);
            timer--;
            timerElement.innerText = timer;
        }
        if (timer === 0) {
            determineWinner({ player1, player2, timerId });
        }
    }

    function drawBackground() {
        // Floor
        c.fillStyle = '#0f172a';
        c.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);
        
        // Neon Grid Floor
        c.save();
        c.strokeStyle = 'rgba(0, 245, 255, 0.2)';
        c.lineWidth = 1;
        c.shadowBlur = 5;
        c.shadowColor = 'cyan';
        
        // Vertical lines (Perspective)
        const vanishingPoint = { x: canvas.width / 2, y: -200 };
        for (let i = -500; i < canvas.width + 500; i += 100) {
            c.beginPath();
            c.moveTo(i, canvas.height);
            c.lineTo((i + vanishingPoint.x) / 2, canvas.height - GROUND_HEIGHT);
            c.stroke();
        }

        // Horizontal lines
        for (let y = canvas.height - GROUND_HEIGHT; y < canvas.height; y += 20) {
            c.beginPath();
            c.moveTo(0, y);
            c.lineTo(canvas.width, y);
            c.stroke();
        }
        c.restore();

        // Background City Silhouette
        c.fillStyle = '#111827';
        c.fillRect(100, canvas.height - GROUND_HEIGHT - 200, 80, 200);
        c.fillRect(200, canvas.height - GROUND_HEIGHT - 300, 120, 300);
        c.fillRect(600, canvas.height - GROUND_HEIGHT - 250, 100, 250);
        c.fillRect(850, canvas.height - GROUND_HEIGHT - 150, 60, 150);
        
        // Windows
        c.fillStyle = 'rgba(255, 255, 0, 0.1)';
        for(let i=0; i<10; i++) {
             c.fillRect(210 + (i%3)*30, canvas.height - GROUND_HEIGHT - 280 + Math.floor(i/3)*40, 20, 30);
        }
    }

    function animate() {
        window.requestAnimationFrame(animate);
        
        // Dark background refresh
        c.fillStyle = '#0B0F1A';
        c.fillRect(0, 0, canvas.width, canvas.height);
        
        drawBackground();

        particles.forEach((particle, index) => {
            if (particle.life <= 0) particles.splice(index, 1);
            else particle.update();
        });

        // AI Logic Update
        if (gameRunning && gameMode === 'ai') {
            updateAI();
        }

        player1.update();
        player2.update();

        // Player 1 Movement
        player1.velocity.x = 0;
        if (!player1.dead && gameRunning) {
            if (keys.a.pressed && player1.lastKey === 'a') {
                player1.velocity.x = -MOVE_SPEED; player1.facingRight = false;
            } else if (keys.d.pressed && player1.lastKey === 'd') {
                player1.velocity.x = MOVE_SPEED; player1.facingRight = true;
            }
        }

        // Player 2 Movement
        player2.velocity.x = 0;
        if (!player2.dead && gameRunning) {
            const p2Left = (gameMode === 'pvp' && keys.ArrowLeft.pressed) || (gameMode === 'ai' && aiKeys.ArrowLeft.pressed);
            const p2Right = (gameMode === 'pvp' && keys.ArrowRight.pressed) || (gameMode === 'ai' && aiKeys.ArrowRight.pressed);
            const p2LastKey = (gameMode === 'pvp') ? player2.lastKey : aiLastKey;

            if (p2Left && p2LastKey === 'ArrowLeft') {
                player2.velocity.x = -MOVE_SPEED;
                player2.facingRight = false;
            } else if (p2Right && p2LastKey === 'ArrowRight') {
                player2.velocity.x = MOVE_SPEED;
                player2.facingRight = true;
            }
        }

        // Collisions
        if (rectangularCollision({ rectangle1: player1, rectangle2: player2 }) &&
            player1.isAttacking && player1.animationFrame % 2 === 0
        ) {
            player1.isAttacking = false; 
            player2.takeHit(10);
            p2HealthBar.style.width = player2.health + '%';
        }

        if (rectangularCollision({ rectangle1: player2, rectangle2: player1 }) &&
            player2.isAttacking && player2.animationFrame % 2 === 0
        ) {
            player2.isAttacking = false;
            player1.takeHit(10);
            p1HealthBar.style.width = player1.health + '%';
        }

        if ((player1.health <= 0 || player2.health <= 0) && gameRunning) {
            determineWinner({ player1, player2, timerId });
        }
    }

    // Start Loop
    animate();

    // --- GAME CONTROL FUNCTIONS ---

    window.startGame = function(mode) {
        gameMode = mode;
        startScreen.style.display = 'none';
        resetMatch();
    };

    window.showMainMenu = function() {
        gameRunning = false;
        resultScreen.style.display = 'none';
        startScreen.style.display = 'flex';
    };

    window.resetMatch = function() {
        player1.health = 100; player2.health = 100;
        player1.dead = false; player2.dead = false;
        player1.position = { x: 100, y: 0 };
        player2.position = { x: 800, y: 0 };
        player1.facingRight = true; player2.facingRight = false;
        p1HealthBar.style.width = '100%'; p2HealthBar.style.width = '100%';
        timer = 60;
        resultScreen.style.display = 'none';
        gameRunning = true;
        clearTimeout(timerId);
        decreaseTimer();
    };

    // Event Listeners
    window.addEventListener('keydown', (event) => {
        if (!gameRunning) return;

        switch (event.key) {
            // P1
            case 'd': case 'D': keys.d.pressed = true; player1.lastKey = 'd'; break;
            case 'a': case 'A': keys.a.pressed = true; player1.lastKey = 'a'; break;
            case 'w': case 'W': 
                if (!player1.isJumping && !player1.dead) { player1.velocity.y = JUMP_FORCE; player1.isJumping = true; } break;
            case 'f': case 'F': player1.attack(); break;
            case 'g': case 'G': player1.block(true); break;

            // P2 (PvP only)
            case 'ArrowRight': 
                if(gameMode === 'pvp') { keys.ArrowRight.pressed = true; player2.lastKey = 'ArrowRight'; } break;
            case 'ArrowLeft': 
                if(gameMode === 'pvp') { keys.ArrowLeft.pressed = true; player2.lastKey = 'ArrowLeft'; } break;
            case 'ArrowUp': 
                if(gameMode === 'pvp' && !player2.isJumping && !player2.dead) { player2.velocity.y = JUMP_FORCE; player2.isJumping = true; } break;
            case '0': if(gameMode === 'pvp') player2.attack(); break;
            case '.': if(gameMode === 'pvp') player2.block(true); break;
        }
        
        if (gameMode === 'pvp') {
            if (event.code === 'Numpad0') player2.attack();
            if (event.code === 'NumpadDecimal') player2.block(true);
        }
    });

    window.addEventListener('keyup', (event) => {
        switch (event.key) {
            case 'd': case 'D': keys.d.pressed = false; break;
            case 'a': case 'A': keys.a.pressed = false; break;
            case 'g': case 'G': player1.block(false); break;

            case 'ArrowRight': keys.ArrowRight.pressed = false; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed = false; break;
            case '.': player2.block(false); break;
        }
        if (event.code === 'NumpadDecimal') player2.block(false);
    });
</script>
</body>
</html>